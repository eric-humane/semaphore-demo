---
- name: System + firmware update with conditional reboot
  hosts: spark
  become: true
  max_fail_percentage: 0
  vars:
    reboot_timeout: 900

  tasks:
    # --- Preflight (prove become + show who we are) ---

    - name: Preflight - show remote user (no become)
      ansible.builtin.command: whoami
      register: whoami_plain
      changed_when: false

    - name: Preflight - must be root via become
      ansible.builtin.command: id -u
      register: uid_root
      changed_when: false

    - name: Fail if become is not working
      ansible.builtin.fail:
        msg: "Become is not active. remote_user={{ whoami_plain.stdout }}, uid_with_become={{ uid_root.stdout }}."
      when: uid_root.stdout != "0"

    # --- APT: deterministic + avoid lock races ---

    - name: List systemd unit files (for conditional service/timer handling)
      ansible.builtin.command: systemctl list-unit-files
      register: unit_files
      changed_when: false

    - name: Stop apt background services that hold locks (if present)
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - apt-daily.service
        - apt-daily-upgrade.service
        - unattended-upgrades.service
      when: item in unit_files.stdout

    - name: Disable apt background timers (temporary for this run, if present)
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: stopped
        enabled: false
      loop:
        - apt-daily.timer
        - apt-daily-upgrade.timer
      when: item in unit_files.stdout

    - name: Wait for dpkg/apt locks to clear
      ansible.builtin.shell: |
        set -euo pipefail
        for f in /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/lib/apt/lists/lock; do
          while fuser "$f" >/dev/null 2>&1; do
            sleep 2
          done
        done
      args:
        executable: /bin/bash
      changed_when: false

    - name: apt update (apt-get so stderr is visible in Semaphore logs)
      ansible.builtin.shell: |
        set -euo pipefail
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -y
      args:
        executable: /bin/bash
      register: apt_update
      changed_when: false

    - name: apt dist-upgrade
      ansible.builtin.shell: |
        set -euo pipefail
        export DEBIAN_FRONTEND=noninteractive
        apt-get -o Dpkg::Options::="--force-confnew" dist-upgrade -y
      args:
        executable: /bin/bash
      register: apt_upgrade
      changed_when: "'0 upgraded' not in (apt_upgrade.stdout + apt_upgrade.stderr)"

    - name: Show apt dist-upgrade output (tail)
      ansible.builtin.debug:
        msg: |
          apt dist-upgrade (rc={{ apt_upgrade.rc }})
          --- stdout (tail) ---
          {{ ((apt_upgrade.stdout | default('')) | split('\n'))[-30:] | join('\n') }}
          --- stderr (tail) ---
          {{ ((apt_upgrade.stderr | default('')) | split('\n'))[-30:] | join('\n') }}

    # --- SNAP (update/upgrade) ---

    - name: Check if snap is installed
      ansible.builtin.command: bash -lc "command -v snap"
      register: snap_cmd
      changed_when: false
      failed_when: false

    - name: snap refresh (update/upgrade snaps)
      ansible.builtin.command: snap refresh
      register: snap_refresh
      changed_when: >
        (snap_refresh.stdout | lower) is not search("all snaps up to date") and
        (snap_refresh.stdout | lower) is not search("no updates available")
      when: snap_cmd.rc == 0

    - name: Show snap refresh output
      ansible.builtin.debug:
        msg: |
          snap refresh (rc={{ snap_refresh.rc }})
          {{ snap_refresh.stdout | default('') }}
          {{ snap_refresh.stderr | default('') }}
      when: snap_cmd.rc == 0

    # --- FWUPD ---

    - name: Check if fwupdmgr is installed
      ansible.builtin.command: bash -lc "command -v fwupdmgr"
      register: fwupd_cmd
      changed_when: false
      failed_when: false

    - name: Refresh fwupd metadata
      ansible.builtin.command: fwupdmgr refresh --force
      changed_when: false
      when: fwupd_cmd.rc == 0

    - name: Apply firmware updates
      ansible.builtin.command: fwupdmgr upgrade -y
      register: fwupd_upgrade
      failed_when: fwupd_upgrade.rc not in [0, 2]   # 2 == no updates
      changed_when: fwupd_upgrade.rc == 0
      when: fwupd_cmd.rc == 0

    - name: Show fwupdmgr upgrade output
      ansible.builtin.debug:
        msg: |
          fwupdmgr upgrade (rc={{ fwupd_upgrade.rc }})
          {{ fwupd_upgrade.stdout | default('') }}
          {{ fwupd_upgrade.stderr | default('') }}
      when: fwupd_cmd.rc == 0

    - name: Skip fwupd (not installed)
      ansible.builtin.debug:
        msg: "fwupdmgr not installed on host; skipping firmware refresh/upgrade."
      when: fwupd_cmd.rc != 0

    # --- Reboot detection + reboot ---

    - name: Check if reboot is required (apt)
      ansible.builtin.stat:
        path: /var/run/reboot-required
      register: reboot_required_apt

    - name: Check if reboot is required (fwupd)
      ansible.builtin.command: fwupdmgr get-devices
      register: fwupd_devices
      changed_when: false
      when: fwupd_cmd.rc == 0

    - name: Determine if reboot is required
      ansible.builtin.set_fact:
        reboot_required: >-
          {{
            reboot_required_apt.stat.exists or
            ('reboot' in (fwupd_devices.stdout | default('') | lower))
          }}

    - name: Log reboot decision
      ansible.builtin.debug:
        msg: "reboot_required={{ reboot_required }} (apt={{ reboot_required_apt.stat.exists }}, fwupd_reboot_hint={{ 'reboot' in (fwupd_devices.stdout | default('') | lower) }})"

    - name: Reboot if required (fast return)
      ansible.builtin.reboot:
        msg: "Reboot initiated by Ansible after system/firmware updates"
        reboot_timeout: "{{ reboot_timeout }}"
        pre_reboot_delay: 0
        post_reboot_delay: 5
        connect_timeout: 5
        test_command: "systemctl is-system-running --wait || true"
      register: reboot_result
      when: reboot_required

    - name: Show reboot timing
      ansible.builtin.debug:
        msg: |
          reboot: changed={{ reboot_result.changed | default(false) }}
          elapsed={{ reboot_result.elapsed | default('unknown') }}s
          msg={{ reboot_result.msg | default('') }}
      when: reboot_required
